C APTITUDE MASTER SUMMARY ‚Äî Questions, Concepts & Tricks

1Ô∏è‚É£ Loop decrement and print pattern
-----------------------------------
Code:
for (n = 7; n != 0; n--) printf("n = %d", n--);
Trick: post-decrement happens twice.
Output: 7, 5, 3, 1

2Ô∏è‚É£ Bitwise left shift with negative number
-------------------------------------------
printf("%x", -1 << 1);
Trick: -1 = 0xFFFFFFFF (32-bit); shift ‚Üí 0xFFFFFFFE.
Output: fffffffe

3Ô∏è‚É£ Macro without parentheses
------------------------------
#define prod(a,b) a*b
printf("%d", prod(x+2,y-1));
Trick: expands to x+2*y-1 ‚Üí wrong precedence.
Output: 10
Fix: #define prod(a,b) ((a)*(b))

4Ô∏è‚É£ Static variable recursion
------------------------------
static int i=5; if(--i){main(); printf("%d ",i);}
Trick: Static persists across calls.
Output: 0 0 0 0

5Ô∏è‚É£ scanf return value
-----------------------
scanf("%d",&x);
printf("%d", scanf("%d",&x));
Trick: scanf returns number of successful reads.
Output: 1

6Ô∏è‚É£ Unsigned overflow
----------------------
unsigned int i=65000; while(i++!=0); printf("%u",i);
Trick: Wrap-around ‚Üí next value = 1.
Output: 1

7Ô∏è‚É£ signed char overflow
-------------------------
signed char i=0; for(;i>=0;i++); printf("%d",i);
Range: -128 to 127.
Output: -128

8Ô∏è‚É£ Function call argument order
--------------------------------
f(i++,i++,i++);
Order unspecified ‚Üí undefined behavior.
Outputs: 10 11 12 13 OR 12 11 10 13.

9Ô∏è‚É£ Calling convention (pascal vs cdecl)
----------------------------------------
Pascal ‚Üí Left to Right, Cdecl ‚Üí Right to Left
Outputs:
10 11 12 13
12 11 10 13

üîü Pointer arithmetic increment
--------------------------------
++*ptr++;
Trick: Increment value, then move pointer.
Output: modified string ("hffltgpshfflt")

11Ô∏è‚É£ Label inside another function
----------------------------------
goto inside_foo; // invalid across functions
Trick: Labels local to same function.

12Ô∏è‚É£ printf field width
------------------------
printf("%*d",x,p);
Trick: Dynamic width; x=5 ‚Üí "   10"
Output:    10

13Ô∏è‚É£ Pointer vs array address
-----------------------------
if(&p == (char*)&arr) printf("Same");
Output: Not same

14Ô∏è‚É£ sizeof pointer vs array
-----------------------------
char arr[]={1,2,3}; char *p=arr;
sizeof(p)=8, sizeof(arr)=3
Output: 8 3

15Ô∏è‚É£ Shadowed global variable
------------------------------
int x=0; int f(){return x;} int g(){int x=1;return f();}
Trick: f() sees global variable.
Output: 0

16Ô∏è‚É£ Shift operators in printf
-------------------------------
printf("%d %d %d",c,c<<=2,c>>=2);
Trick: modifies same var ‚Üí undefined.
Possible: 5 20 5 OR 4 4 1

17Ô∏è‚É£ Array decay in sizeof
---------------------------
Inside func, array decays ‚Üí pointer.
Output: 8 (64-bit), not 3.

18Ô∏è‚É£ Pointer vs pointer-to-const
--------------------------------
void fun(const char **p); fun(argv);
Trick: char** ‚Üí const char** invalid.
Fix: fun(char * const *p)

19Ô∏è‚É£ Pointer arithmetic simplification
--------------------------------------
*a+1-*a+3 = 4 (cancel same terms)
Output: 4

20Ô∏è‚É£ String pointer equivalence
-------------------------------
str[i] == *(str+i) == *(i+str) == i[str]
Output:
gggg
eeee
kkkk
ssss ...

21Ô∏è‚É£ signed vs unsigned wrap-up
--------------------------------
signed overflow ‚Üí undefined
unsigned overflow ‚Üí wraps to 0

22Ô∏è‚É£ sizeof in summary
-----------------------
sizeof(pointer) = 4/8 bytes
sizeof(array) = N * sizeof(type)

Golden Rules
-------------
1. Never modify/read same variable in one expression.
2. Use parentheses in macros.
3. Arrays decay to pointers (except in sizeof or &).
4. Unsigned wraps; signed overflows undefined.
5. Function argument order unspecified.
6. Static persists; locals reset.
7. Pointer size fixed, array size dynamic.
8. goto valid only inside same function.
9. const correctness: char** != const char**.
10. i[arr] == arr[i].

